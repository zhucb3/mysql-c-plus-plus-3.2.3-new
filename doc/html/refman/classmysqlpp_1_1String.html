<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mysqlpp</b></li><li class="navelem"><a class="el" href="classmysqlpp_1_1String.html">String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmysqlpp_1_1String-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mysqlpp::String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A std::string work-alike that can convert itself from SQL text data formats to C++ data types.  
 <a href="classmysqlpp_1_1String.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mystring_8h_source.html">mystring.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2ac840e79adca00ed4f3858ed1e1f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2ac840e79adca00ed4f3858ed1e1f75"></a>
typedef const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af2ac840e79adca00ed4f3858ed1e1f75">value_type</a></td></tr>
<tr class="memdesc:af2ac840e79adca00ed4f3858ed1e1f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the data stored in this object, when it is not equal to SQL null. <br/></td></tr>
<tr class="separator:af2ac840e79adca00ed4f3858ed1e1f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b6729bef9c0a50914a142c361c44b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5b6729bef9c0a50914a142c361c44b7"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a></td></tr>
<tr class="memdesc:af5b6729bef9c0a50914a142c361c44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of "size" integers. <br/></td></tr>
<tr class="separator:af5b6729bef9c0a50914a142c361c44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c18cd6c1fb2d3130e80b10ff00550e5"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a></td></tr>
<tr class="memdesc:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iterators. <br/></td></tr>
<tr class="separator:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a55310c5344694df502667a432cc3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a55310c5344694df502667a432cc3d"></a>
typedef <a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac9a55310c5344694df502667a432cc3d">iterator</a></td></tr>
<tr class="memdesc:ac9a55310c5344694df502667a432cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const_iterator because the data cannot be changed. <br/></td></tr>
<tr class="separator:ac9a55310c5344694df502667a432cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae711df130eb705131bb4121b58114304"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a> ()</td></tr>
<tr class="memdesc:ae711df130eb705131bb4121b58114304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae711df130eb705131bb4121b58114304">More...</a><br/></td></tr>
<tr class="separator:ae711df130eb705131bb4121b58114304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e81654babcc5d285b3e9f838833bd88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7e81654babcc5d285b3e9f838833bd88">String</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>
<tr class="memdesc:a7e81654babcc5d285b3e9f838833bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ctor.  <a href="#a7e81654babcc5d285b3e9f838833bd88">More...</a><br/></td></tr>
<tr class="separator:a7e81654babcc5d285b3e9f838833bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ff5d5045cbca01c441d2b1b1b02136"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af5ff5d5045cbca01c441d2b1b1b02136">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:af5ff5d5045cbca01c441d2b1b1b02136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="#af5ff5d5045cbca01c441d2b1b1b02136">More...</a><br/></td></tr>
<tr class="separator:af5ff5d5045cbca01c441d2b1b1b02136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af6d39e2ae5aeb13761b80fafcfdcb8a0">String</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ string version of full ctor.  <a href="#af6d39e2ae5aeb13761b80fafcfdcb8a0">More...</a><br/></td></tr>
<tr class="separator:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb546bc0f5231627b93c66746a9cd3c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#afb546bc0f5231627b93c66746a9cd3c0">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:afb546bc0f5231627b93c66746a9cd3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-terminated C string version of full ctor.  <a href="#afb546bc0f5231627b93c66746a9cd3c0">More...</a><br/></td></tr>
<tr class="separator:afb546bc0f5231627b93c66746a9cd3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e145f153028b0932fe916159f803dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e145f153028b0932fe916159f803dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a43e145f153028b0932fe916159f803dc">~String</a> ()</td></tr>
<tr class="memdesc:a43e145f153028b0932fe916159f803dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy string. <br/></td></tr>
<tr class="separator:a43e145f153028b0932fe916159f803dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a07d5fc7add1e11e9f11b8169a7f2c792">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign raw data to this object.  <a href="#a07d5fc7add1e11e9f11b8169a7f2c792">More...</a><br/></td></tr>
<tr class="separator:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a2495cd58ddbf6427747d8bbfefd4f5b7">assign</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a C++ string to this object.  <a href="#a2495cd58ddbf6427747d8bbfefd4f5b7">More...</a><br/></td></tr>
<tr class="separator:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30624cfe0e895bb2e20d653c35cca80c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a30624cfe0e895bb2e20d653c35cca80c">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a>=false)</td></tr>
<tr class="memdesc:a30624cfe0e895bb2e20d653c35cca80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a C string to this object.  <a href="#a30624cfe0e895bb2e20d653c35cca80c">More...</a><br/></td></tr>
<tr class="separator:a30624cfe0e895bb2e20d653c35cca80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9503b161cf2146cf99c472dadbf0e16"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ad9503b161cf2146cf99c472dadbf0e16">at</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const </td></tr>
<tr class="memdesc:ad9503b161cf2146cf99c472dadbf0e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a character within the string.  <a href="#ad9503b161cf2146cf99c472dadbf0e16">More...</a><br/></td></tr>
<tr class="separator:ad9503b161cf2146cf99c472dadbf0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af459c83601d1977d5ca2c3394d374f2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af459c83601d1977d5ca2c3394d374f2c"></a>
<a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af459c83601d1977d5ca2c3394d374f2c">begin</a> () const </td></tr>
<tr class="memdesc:af459c83601d1977d5ca2c3394d374f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the first character of the string. <br/></td></tr>
<tr class="separator:af459c83601d1977d5ca2c3394d374f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b518885611f7f2275ef4da6205c8272"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b518885611f7f2275ef4da6205c8272"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7b518885611f7f2275ef4da6205c8272">c_str</a> () const </td></tr>
<tr class="memdesc:a7b518885611f7f2275ef4da6205c8272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the string data. <br/></td></tr>
<tr class="separator:a7b518885611f7f2275ef4da6205c8272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ef12fe783032f84aefd2aba444b5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab35ef12fe783032f84aefd2aba444b5f"></a>
template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab35ef12fe783032f84aefd2aba444b5f"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ab35ef12fe783032f84aefd2aba444b5f">conv</a> (Type) const </td></tr>
<tr class="memdesc:ab35ef12fe783032f84aefd2aba444b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for converting the column data to most any numeric data type. <br/></td></tr>
<tr class="separator:ab35ef12fe783032f84aefd2aba444b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec934fca9e51900e191c2bc43fe8a17c"><td class="memTemplParams" colspan="2">template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:aec934fca9e51900e191c2bc43fe8a17c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aec934fca9e51900e191c2bc43fe8a17c">conv</a> (<a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;) const </td></tr>
<tr class="memdesc:aec934fca9e51900e191c2bc43fe8a17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <a class="el" href="classmysqlpp_1_1String.html#ab35ef12fe783032f84aefd2aba444b5f" title="Template for converting the column data to most any numeric data type. ">conv()</a> for types wrapped with Null&lt;&gt;  <a href="#aec934fca9e51900e191c2bc43fe8a17c">More...</a><br/></td></tr>
<tr class="separator:aec934fca9e51900e191c2bc43fe8a17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289c025d3e2900fd5b3fc6a0b971116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116">compare</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other) const </td></tr>
<tr class="memdesc:a9289c025d3e2900fd5b3fc6a0b971116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#a9289c025d3e2900fd5b3fc6a0b971116">More...</a><br/></td></tr>
<tr class="separator:a9289c025d3e2900fd5b3fc6a0b971116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590200af942b7d3fa1e99c453fc5feee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a590200af942b7d3fa1e99c453fc5feee">compare</a> (const std::string &amp;other) const </td></tr>
<tr class="memdesc:a590200af942b7d3fa1e99c453fc5feee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#a590200af942b7d3fa1e99c453fc5feee">More...</a><br/></td></tr>
<tr class="separator:a590200af942b7d3fa1e99c453fc5feee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129f6059c6c35afa47e11f1786784467"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a129f6059c6c35afa47e11f1786784467">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> num, std::string &amp;other) const </td></tr>
<tr class="memdesc:a129f6059c6c35afa47e11f1786784467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#a129f6059c6c35afa47e11f1786784467">More...</a><br/></td></tr>
<tr class="separator:a129f6059c6c35afa47e11f1786784467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924df971ce7e56b77c8cce404da4cd69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a924df971ce7e56b77c8cce404da4cd69">compare</a> (const char *other) const </td></tr>
<tr class="memdesc:a924df971ce7e56b77c8cce404da4cd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#a924df971ce7e56b77c8cce404da4cd69">More...</a><br/></td></tr>
<tr class="separator:a924df971ce7e56b77c8cce404da4cd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426fc8b86291b85a29958440cc8725e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a426fc8b86291b85a29958440cc8725e4">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> num, const char *other) const </td></tr>
<tr class="memdesc:a426fc8b86291b85a29958440cc8725e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#a426fc8b86291b85a29958440cc8725e4">More...</a><br/></td></tr>
<tr class="separator:a426fc8b86291b85a29958440cc8725e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c91b53d9b2998d20c72b942dedc69f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75c91b53d9b2998d20c72b942dedc69f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a75c91b53d9b2998d20c72b942dedc69f">data</a> () const </td></tr>
<tr class="memdesc:a75c91b53d9b2998d20c72b942dedc69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw access to the underlying buffer, with no C string interpretation. <br/></td></tr>
<tr class="separator:a75c91b53d9b2998d20c72b942dedc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1cd5673ac2919cf05e2ce8bf99489d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e1cd5673ac2919cf05e2ce8bf99489d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a0e1cd5673ac2919cf05e2ce8bf99489d">empty</a> () const </td></tr>
<tr class="memdesc:a0e1cd5673ac2919cf05e2ce8bf99489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="classmysqlpp_1_1String.html#acb5da2601dc9f7d50c0793d76ab94817" title="Return number of bytes in string. ">size()</a> == 0. <br/></td></tr>
<tr class="separator:a0e1cd5673ac2919cf05e2ce8bf99489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45da6949d25235fb08146cc54423184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac45da6949d25235fb08146cc54423184"></a>
<a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac45da6949d25235fb08146cc54423184">end</a> () const </td></tr>
<tr class="memdesc:ac45da6949d25235fb08146cc54423184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to one past the last character of the string. <br/></td></tr>
<tr class="separator:ac45da6949d25235fb08146cc54423184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693c487decac34ba8fcd78e8f77f822f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a693c487decac34ba8fcd78e8f77f822f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a693c487decac34ba8fcd78e8f77f822f">escape_q</a> () const </td></tr>
<tr class="memdesc:a693c487decac34ba8fcd78e8f77f822f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data of this type should be escaped, false otherwise. <br/></td></tr>
<tr class="separator:a693c487decac34ba8fcd78e8f77f822f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1a09ac03c7aedb4ce8242b64c99105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae1a09ac03c7aedb4ce8242b64c99105"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aae1a09ac03c7aedb4ce8242b64c99105">is_null</a> () const </td></tr>
<tr class="memdesc:aae1a09ac03c7aedb4ce8242b64c99105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is a SQL null. <br/></td></tr>
<tr class="separator:aae1a09ac03c7aedb4ce8242b64c99105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73442369274b0a9425061b8e0cc139f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac73442369274b0a9425061b8e0cc139f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac73442369274b0a9425061b8e0cc139f">it_is_null</a> ()</td></tr>
<tr class="memdesc:ac73442369274b0a9425061b8e0cc139f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmysqlpp_1_1Set.html" title="A special std::set derivative for holding MySQL data sets. ">Set</a> a flag indicating that this object is a SQL null. <br/></td></tr>
<tr class="separator:ac73442369274b0a9425061b8e0cc139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631286a235165cc9c2b653b5d852f65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c">length</a> () const </td></tr>
<tr class="memdesc:a631286a235165cc9c2b653b5d852f65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in the string.  <a href="#a631286a235165cc9c2b653b5d852f65c">More...</a><br/></td></tr>
<tr class="separator:a631286a235165cc9c2b653b5d852f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1e47982e7ad8f2cbe3da71be02999e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a4e1e47982e7ad8f2cbe3da71be02999e">max_size</a> () const </td></tr>
<tr class="memdesc:a4e1e47982e7ad8f2cbe3da71be02999e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of characters in the string.  <a href="#a4e1e47982e7ad8f2cbe3da71be02999e">More...</a><br/></td></tr>
<tr class="separator:a4e1e47982e7ad8f2cbe3da71be02999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15315731fe907f655c48018a4d86e484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15315731fe907f655c48018a4d86e484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a15315731fe907f655c48018a4d86e484">quote_q</a> () const </td></tr>
<tr class="memdesc:a15315731fe907f655c48018a4d86e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data of this type should be quoted, false otherwise. <br/></td></tr>
<tr class="separator:a15315731fe907f655c48018a4d86e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5da2601dc9f7d50c0793d76ab94817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#acb5da2601dc9f7d50c0793d76ab94817">size</a> () const </td></tr>
<tr class="memdesc:acb5da2601dc9f7d50c0793d76ab94817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in string.  <a href="#acb5da2601dc9f7d50c0793d76ab94817">More...</a><br/></td></tr>
<tr class="separator:acb5da2601dc9f7d50c0793d76ab94817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deb0dc258c0e2920fba90fdf53baf97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3deb0dc258c0e2920fba90fdf53baf97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a3deb0dc258c0e2920fba90fdf53baf97">strip_leading_blanks</a> (std::string &amp;s) const </td></tr>
<tr class="memdesc:a3deb0dc258c0e2920fba90fdf53baf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of our internal string without leading blanks. <br/></td></tr>
<tr class="separator:a3deb0dc258c0e2920fba90fdf53baf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5832628cdfc820e57ddd44f16ad6c282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a5832628cdfc820e57ddd44f16ad6c282">to_string</a> (std::string &amp;s) const </td></tr>
<tr class="memdesc:a5832628cdfc820e57ddd44f16ad6c282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this object's data into a C++ string.  <a href="#a5832628cdfc820e57ddd44f16ad6c282">More...</a><br/></td></tr>
<tr class="separator:a5832628cdfc820e57ddd44f16ad6c282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a1090c2f5a667937c2eb21b7ad3da6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54a1090c2f5a667937c2eb21b7ad3da6"></a>
<a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a54a1090c2f5a667937c2eb21b7ad3da6">type</a> () const </td></tr>
<tr class="memdesc:a54a1090c2f5a667937c2eb21b7ad3da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's current MySQL type. <br/></td></tr>
<tr class="separator:a54a1090c2f5a667937c2eb21b7ad3da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31d730d66f311a4045bf62b170869d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f31d730d66f311a4045bf62b170869d"></a>
<a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d">operator=</a> (const std::string &amp;rhs)</td></tr>
<tr class="memdesc:a6f31d730d66f311a4045bf62b170869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from C++ string. <br/></td></tr>
<tr class="separator:a6f31d730d66f311a4045bf62b170869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc9c3f4dd56805e844aba503b175bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7bc9c3f4dd56805e844aba503b175bcd">operator=</a> (const char *str)</td></tr>
<tr class="memdesc:a7bc9c3f4dd56805e844aba503b175bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from C string.  <a href="#a7bc9c3f4dd56805e844aba503b175bcd">More...</a><br/></td></tr>
<tr class="separator:a7bc9c3f4dd56805e844aba503b175bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1252d1e232376f6493755b49761fa439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a1252d1e232376f6493755b49761fa439">operator=</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>
<tr class="memdesc:a1252d1e232376f6493755b49761fa439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>.  <a href="#a1252d1e232376f6493755b49761fa439">More...</a><br/></td></tr>
<tr class="separator:a1252d1e232376f6493755b49761fa439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c17a38560b6ea57ae6acf5ae9e9e176"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c17a38560b6ea57ae6acf5ae9e9e176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a4c17a38560b6ea57ae6acf5ae9e9e176">operator==</a> (const T &amp;rhs) const </td></tr>
<tr class="memdesc:a4c17a38560b6ea57ae6acf5ae9e9e176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="#a4c17a38560b6ea57ae6acf5ae9e9e176">More...</a><br/></td></tr>
<tr class="separator:a4c17a38560b6ea57ae6acf5ae9e9e176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6704f745f7412724fed0caacdb321417"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a6704f745f7412724fed0caacdb321417">operator==</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const </td></tr>
<tr class="memdesc:a6704f745f7412724fed0caacdb321417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="#a6704f745f7412724fed0caacdb321417">More...</a><br/></td></tr>
<tr class="separator:a6704f745f7412724fed0caacdb321417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb9e6f4d71ee73551dc722fd56c4f89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bb9e6f4d71ee73551dc722fd56c4f89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9bb9e6f4d71ee73551dc722fd56c4f89">operator!=</a> (const T &amp;rhs) const </td></tr>
<tr class="memdesc:a9bb9e6f4d71ee73551dc722fd56c4f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <a href="#a9bb9e6f4d71ee73551dc722fd56c4f89">More...</a><br/></td></tr>
<tr class="separator:a9bb9e6f4d71ee73551dc722fd56c4f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed535131fdcff79909822ed937d99972"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aed535131fdcff79909822ed937d99972">operator!=</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const </td></tr>
<tr class="memdesc:aed535131fdcff79909822ed937d99972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <a href="#aed535131fdcff79909822ed937d99972">More...</a><br/></td></tr>
<tr class="separator:aed535131fdcff79909822ed937d99972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3604ef3820103e67d452b8b44dcd64d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af3604ef3820103e67d452b8b44dcd64d">operator[]</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const </td></tr>
<tr class="memdesc:af3604ef3820103e67d452b8b44dcd64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a character within the string.  <a href="#af3604ef3820103e67d452b8b44dcd64d">More...</a><br/></td></tr>
<tr class="separator:af3604ef3820103e67d452b8b44dcd64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff63379de1888dc30b9fde8a55ed37a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adff63379de1888dc30b9fde8a55ed37a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#adff63379de1888dc30b9fde8a55ed37a">operator const char *</a> () const </td></tr>
<tr class="memdesc:adff63379de1888dc30b9fde8a55ed37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const char pointer to the object's raw data. <br/></td></tr>
<tr class="separator:adff63379de1888dc30b9fde8a55ed37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3452dfec79b5f8c42a232de1d308f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b3452dfec79b5f8c42a232de1d308f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a0b3452dfec79b5f8c42a232de1d308f5">operator signed char</a> () const </td></tr>
<tr class="memdesc:a0b3452dfec79b5f8c42a232de1d308f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a signed char. <br/></td></tr>
<tr class="separator:a0b3452dfec79b5f8c42a232de1d308f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844d4549644bef767b688b11b2f7d66a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a844d4549644bef767b688b11b2f7d66a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a844d4549644bef767b688b11b2f7d66a">operator unsigned char</a> () const </td></tr>
<tr class="memdesc:a844d4549644bef767b688b11b2f7d66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned char. <br/></td></tr>
<tr class="separator:a844d4549644bef767b688b11b2f7d66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc5400a915fdb59677b676b5e8fe315"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc5400a915fdb59677b676b5e8fe315"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a3dc5400a915fdb59677b676b5e8fe315">operator int</a> () const </td></tr>
<tr class="memdesc:a3dc5400a915fdb59677b676b5e8fe315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an int. <br/></td></tr>
<tr class="separator:a3dc5400a915fdb59677b676b5e8fe315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b05dc6f7f324b5bf73310bd944ef786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b05dc6f7f324b5bf73310bd944ef786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7b05dc6f7f324b5bf73310bd944ef786">operator unsigned int</a> () const </td></tr>
<tr class="memdesc:a7b05dc6f7f324b5bf73310bd944ef786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned int. <br/></td></tr>
<tr class="separator:a7b05dc6f7f324b5bf73310bd944ef786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb65923cc699ec38e98310380128f43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb65923cc699ec38e98310380128f43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a5fb65923cc699ec38e98310380128f43">operator short int</a> () const </td></tr>
<tr class="memdesc:a5fb65923cc699ec38e98310380128f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a short int. <br/></td></tr>
<tr class="separator:a5fb65923cc699ec38e98310380128f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c493122d43ed4b14aae47f2a98756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a578c493122d43ed4b14aae47f2a98756"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a578c493122d43ed4b14aae47f2a98756">operator unsigned short int</a> () const </td></tr>
<tr class="memdesc:a578c493122d43ed4b14aae47f2a98756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned short int. <br/></td></tr>
<tr class="separator:a578c493122d43ed4b14aae47f2a98756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bc9ccadbec83ff456c0eadc86458f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91bc9ccadbec83ff456c0eadc86458f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af91bc9ccadbec83ff456c0eadc86458f">operator long int</a> () const </td></tr>
<tr class="memdesc:af91bc9ccadbec83ff456c0eadc86458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a long int. <br/></td></tr>
<tr class="separator:af91bc9ccadbec83ff456c0eadc86458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5b2c99c3a20e7ef312d8eebb298587"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5b2c99c3a20e7ef312d8eebb298587"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a0f5b2c99c3a20e7ef312d8eebb298587">operator unsigned long int</a> () const </td></tr>
<tr class="memdesc:a0f5b2c99c3a20e7ef312d8eebb298587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned long int. <br/></td></tr>
<tr class="separator:a0f5b2c99c3a20e7ef312d8eebb298587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9bc5d60f4b4d72fbc00c6821d65cf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f9bc5d60f4b4d72fbc00c6821d65cf7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a2f9bc5d60f4b4d72fbc00c6821d65cf7">operator longlong</a> () const </td></tr>
<tr class="memdesc:a2f9bc5d60f4b4d72fbc00c6821d65cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'longlong' type, usually a 64-bit integer. <br/></td></tr>
<tr class="separator:a2f9bc5d60f4b4d72fbc00c6821d65cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174d4d0e643f1dd65d6ce2372d4d949d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a174d4d0e643f1dd65d6ce2372d4d949d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a174d4d0e643f1dd65d6ce2372d4d949d">operator ulonglong</a> () const </td></tr>
<tr class="memdesc:a174d4d0e643f1dd65d6ce2372d4d949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'ulonglong' type, usually a 64-bit unsigned integer. <br/></td></tr>
<tr class="separator:a174d4d0e643f1dd65d6ce2372d4d949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df602a7f157ffcb64a2141435097d59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9df602a7f157ffcb64a2141435097d59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9df602a7f157ffcb64a2141435097d59">operator float</a> () const </td></tr>
<tr class="memdesc:a9df602a7f157ffcb64a2141435097d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a float. <br/></td></tr>
<tr class="separator:a9df602a7f157ffcb64a2141435097d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209b84d062d8f51a3a0b36ea2af69f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7209b84d062d8f51a3a0b36ea2af69f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7209b84d062d8f51a3a0b36ea2af69f3">operator double</a> () const </td></tr>
<tr class="memdesc:a7209b84d062d8f51a3a0b36ea2af69f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a double. <br/></td></tr>
<tr class="separator:a7209b84d062d8f51a3a0b36ea2af69f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dfd8025327acec9edda4c03839f9e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67dfd8025327acec9edda4c03839f9e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a67dfd8025327acec9edda4c03839f9e3">operator bool</a> () const </td></tr>
<tr class="memdesc:a67dfd8025327acec9edda4c03839f9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a bool. <br/></td></tr>
<tr class="separator:a67dfd8025327acec9edda4c03839f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e4229af9eecd3592f74e3ffe036384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09e4229af9eecd3592f74e3ffe036384"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a09e4229af9eecd3592f74e3ffe036384">operator Date</a> () const </td></tr>
<tr class="memdesc:a09e4229af9eecd3592f74e3ffe036384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Date.html" title="C++ form of SQL&#39;s DATE type. ">mysqlpp::Date</a>. <br/></td></tr>
<tr class="separator:a09e4229af9eecd3592f74e3ffe036384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cf4e66e39dc6a5c021550f50c2e830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45cf4e66e39dc6a5c021550f50c2e830"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a45cf4e66e39dc6a5c021550f50c2e830">operator DateTime</a> () const </td></tr>
<tr class="memdesc:a45cf4e66e39dc6a5c021550f50c2e830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1DateTime.html" title="C++ form of SQL&#39;s DATETIME type. ">mysqlpp::DateTime</a>. <br/></td></tr>
<tr class="separator:a45cf4e66e39dc6a5c021550f50c2e830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888f0711a32d5a4184010ad0bb0bc524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a888f0711a32d5a4184010ad0bb0bc524"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a888f0711a32d5a4184010ad0bb0bc524">operator Time</a> () const </td></tr>
<tr class="memdesc:a888f0711a32d5a4184010ad0bb0bc524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Time.html" title="C++ form of SQL&#39;s TIME type. ">mysqlpp::Time</a>. <br/></td></tr>
<tr class="separator:a888f0711a32d5a4184010ad0bb0bc524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e2316adcba0e0de3207ba395aeb7d4"><td class="memTemplParams" colspan="2">template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:a72e2316adcba0e0de3207ba395aeb7d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a72e2316adcba0e0de3207ba395aeb7d4">operator Null&lt; T, B &gt;</a> () const </td></tr>
<tr class="memdesc:a72e2316adcba0e0de3207ba395aeb7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> to a nullable data type.  <a href="#a72e2316adcba0e0de3207ba395aeb7d4">More...</a><br/></td></tr>
<tr class="separator:a72e2316adcba0e0de3207ba395aeb7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a970c115220fc891e05eef4cc92705457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a970c115220fc891e05eef4cc92705457"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SQLTypeAdapter</b></td></tr>
<tr class="separator:a970c115220fc891e05eef4cc92705457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A std::string work-alike that can convert itself from SQL text data formats to C++ data types. </p>
<p>This class is an intermediate form for a SQL field, normally converted to a more useful native C++ type, not used directly. The only exception is in dealing with BLOB data, which stays in <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> form for efficiency and to avoid corrupting the data with facile conversions. Even then, it's best to use it through the typedef aliases like sql_blob in <a class="el" href="sql__types_8h.html" title="Declares the closest C++ equivalent of each MySQL column type. ">sql_types.h</a>, in case we later change this underlying representation.</p>
<p><a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>'s implicit conversion operators let you can use these objects naturally:</p>
<div class="fragment"><div class="line"><a class="code" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">&quot;12.86&quot;</span>) + 2.0 </div>
</div><!-- fragment --><p>That will give you 14.86 (approximately) as you expect, but be careful not to get tripped up by C++'s type conversion rules. If you had said this instead:</p>
<div class="fragment"><div class="line"><a class="code" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">&quot;12.86&quot;</span>) + 2 </div>
</div><!-- fragment --><p>the result would be 14 because 2 is an integer, and C++'s type conversion rules put the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> object in an integer context.</p>
<p>You can disable the operator overloads that allow these things by defining MYSQLPP_NO_BINARY_OPERS.</p>
<p>This class also has some basic information about the type of data stored in it, to allow it to do the conversions more intelligently than a trivial implementation would allow. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae711df130eb705131bb4121b58114304"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>An object constructed this way is essentially useless, but sometimes you just need to construct a default object. </p>

</div>
</div>
<a class="anchor" id="a7e81654babcc5d285b3e9f838833bd88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> object</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor only copies the pointer to the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>'s data buffer and increments its reference counter. If you need a deep copy, use one of the ctors that takes a string. </p>

</div>
</div>
<a class="anchor" id="af5ff5d5045cbca01c441d2b1b1b02136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Full constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string; embedded nulls are legal </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. The buffer will actually be 1 byte longer than the value given for <code>len</code>, to hold a null terminator for safety. We do this because this ctor may be used for things other than null-terminated C strings. (e.g. BLOB data) </p>

</div>
</div>
<a class="anchor" id="af6d39e2ae5aeb13761b80fafcfdcb8a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ string version of full ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. </p>

</div>
</div>
<a class="anchor" id="afb546bc0f5231627b93c66746a9cd3c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-terminated C string version of full ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a07d5fc7add1e11e9f11b8169a7f2c792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign raw data to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string. ">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a class="anchor" id="a2495cd58ddbf6427747d8bbfefd4f5b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a C++ string to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string. ">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a class="anchor" id="a30624cfe0e895bb2e20d653c35cca80c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a C string to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string. ">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a class="anchor" id="ad9503b161cf2146cf99c472dadbf0e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a character within the string. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmysqlpp_1_1BadIndex.html" title="Exception thrown when an object with operator [] or an at() method gets called with a bad index...">mysqlpp::BadIndex</a></td><td>if the row is not initialized or there are less than <code>i</code> fields in the row. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#aec25bd227cb23caf48c2210013d0f062">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#acb5da2601dc9f7d50c0793d76ab94817">size()</a>.</p>

</div>
</div>
<a class="anchor" id="a9289c025d3e2900fd5b3fc6a0b971116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#aec25bd227cb23caf48c2210013d0f062">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c">length()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1String.html#a590200af942b7d3fa1e99c453fc5feee">compare()</a>.</p>

</div>
</div>
<a class="anchor" id="a590200af942b7d3fa1e99c453fc5feee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116">compare()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c">length()</a>.</p>

</div>
</div>
<a class="anchor" id="a129f6059c6c35afa47e11f1786784467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position within this string to begin comparison </td></tr>
    <tr><td class="paramname">num</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116">compare()</a>.</p>

</div>
</div>
<a class="anchor" id="a924df971ce7e56b77c8cce404da4cd69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116">compare()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c">length()</a>.</p>

</div>
</div>
<a class="anchor" id="a426fc8b86291b85a29958440cc8725e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position within this string to begin comparison </td></tr>
    <tr><td class="paramname">num</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;</td><td>0 if this string is lexically "less than" other </td></tr>
    <tr><td class="paramname">0</td><td>if this string is equal to other </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 if this string is lexically "greater than" other </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1String.html#a75c91b53d9b2998d20c72b942dedc69f">data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c">length()</a>.</p>

</div>
</div>
<a class="anchor" id="aec934fca9e51900e191c2bc43fe8a17c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt;T, B&gt; mysqlpp::String::conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of <a class="el" href="classmysqlpp_1_1String.html#ab35ef12fe783032f84aefd2aba444b5f" title="Template for converting the column data to most any numeric data type. ">conv()</a> for types wrapped with Null&lt;&gt; </p>
<p>If the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> object was initialized with some string we recognize as a SQL null, we just return a copy of the global 'null' object converted to the requested type. Otherwise, we return the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>'s value wrapped in the Null&lt;&gt; template. </p>

</div>
</div>
<a class="anchor" id="a631286a235165cc9c2b653b5d852f65c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">String::size_type</a> mysqlpp::String::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of bytes in the string. </p>
<p>Note that this doesn't count the number of <b>characters</b> in the string. If your database is configured to use an 8-bit character set, this is a distinction without a difference. But, if you're using UTF-8 in the database, you will need to "widen" the UTF-8 data to use a fixed-size character set like UCS-2 and count the characters that way. You might use std::wstring, for example. </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#aa2f38c8213db211e2d473aafca9397b4">mysqlpp::SQLBuffer::length()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116">compare()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e1e47982e7ad8f2cbe3da71be02999e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of characters in the string. </p>
<p>Because this is a <code>const</code> string, this is just an alias for <a class="el" href="classmysqlpp_1_1String.html#acb5da2601dc9f7d50c0793d76ab94817" title="Return number of bytes in string. ">size()</a>; its size is always equal to the amount of data currently stored. </p>

</div>
</div>
<a class="anchor" id="a72e2316adcba0e0de3207ba395aeb7d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::operator <a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a> to a nullable data type. </p>
<p>This is just an implicit version of conv(Null&lt;T, B&gt;) </p>

</div>
</div>
<a class="anchor" id="a9bb9e6f4d71ee73551dc722fd56c4f89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116" title="Lexically compare this string to another. ">compare()</a> overload for. </p>

</div>
</div>
<a class="anchor" id="aed535131fdcff79909822ed937d99972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>For checking object against MySQL++'s global <code>null</code> constant </p>

</div>
</div>
<a class="anchor" id="a7bc9c3f4dd56805e844aba503b175bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator, from C string. </p>
<p>This creates a copy of the entire string, not just a copy of the pointer. </p>

<p>References <a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysqlpp::mysql_type_info::string_type</a>.</p>

</div>
</div>
<a class="anchor" id="a1252d1e232376f6493755b49761fa439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>. </p>
<p>This only copies the pointer to the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types...">String</a>'s data buffer and increments its reference counter. If you need a deep copy, assign a string to this object instead. </p>

</div>
</div>
<a class="anchor" id="a4c17a38560b6ea57ae6acf5ae9e9e176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#a9289c025d3e2900fd5b3fc6a0b971116" title="Lexically compare this string to another. ">compare()</a> overload for. </p>

</div>
</div>
<a class="anchor" id="a6704f745f7412724fed0caacdb321417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>For checking object against MySQL++'s global <code>null</code> constant </p>

</div>
</div>
<a class="anchor" id="af3604ef3820103e67d452b8b44dcd64d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a character within the string. </p>
<p>This function is just syntactic sugar, wrapping the <a class="el" href="classmysqlpp_1_1String.html#ad9503b161cf2146cf99c472dadbf0e16" title="Return a character within the string. ">at()</a> method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmysqlpp_1_1BadIndex.html" title="Exception thrown when an object with operator [] or an at() method gets called with a bad index...">mysqlpp::BadIndex</a></td><td>if the string is not initialized or there are less than <code>i</code> fields in the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb5da2601dc9f7d50c0793d76ab94817"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes in string. </p>
<p>See commentary for <a class="el" href="classmysqlpp_1_1String.html#a631286a235165cc9c2b653b5d852f65c" title="Return number of bytes in the string. ">length()</a> about the difference between bytes and characters. </p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1String.html#ad9503b161cf2146cf99c472dadbf0e16">at()</a>.</p>

</div>
</div>
<a class="anchor" id="a5832628cdfc820e57ddd44f16ad6c282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this object's data into a C++ string. </p>
<p>If you know the data doesn't contain null characters (i.e. it's a typical string, not BLOB data), it's more efficient to just assign this object to anything taking <code>const</code> <code>char*</code>. (Or equivalently, call the <code><a class="el" href="classmysqlpp_1_1String.html#a75c91b53d9b2998d20c72b942dedc69f" title="Raw access to the underlying buffer, with no C string interpretation. ">data()</a></code> method.) This copies a pointer to a buffer instead of copying the buffer's contents. </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#aec25bd227cb23caf48c2210013d0f062">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1SQLBuffer.html#aa2f38c8213db211e2d473aafca9397b4">mysqlpp::SQLBuffer::length()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mystring_8h_source.html">mystring.h</a></li>
<li>mystring.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 30 2016 16:39:48 for MySQL++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
